?? Situation Breakdown:


User logs in at 9:00 AM (clock-in recorded).


User accidentally logs out or closes the app at 12:00 PM (no clock-out recorded).


User logs in again at 1:00 PM and works till 6:00 PM.

System ends up with:


Clock-in: 09:00


Clock-in: 13:00


Clock-out: 18:00

? 1. Detect Missing Clock-Outs (Auto Clock-Out)
If a new clockin is registered without a previous clockout, automatically mark the previous session with
:{
  "status": "auto-clockout",
  "timestamp": timeOfNewClockin - 1 minute
}

? 2. Prevent Duplicate Clock-ins

When a user logs in, check:


If they already have a clock-in without a clock-out, don't record another clock-in.


Instead, warn them or merge the session.

? 3. Session Recovery Notification

If a previous session was incomplete, notify the user:

“?? You had an incomplete session earlier today.
 We've auto clocked you out at 12:00 PM. 
Please confirm or edit this.”

? 4. Display Gaps Clearly in Timeline

On the frontend, show such sessions with a distinct color (e.g., red for "auto-clockout")
 so they’re visibly different from standard clock-outs.

import React, { useEffect, useState } from 'react';
import { ScrollView, ActivityIndicator, Pressable } from 'react-native';
import { Box, Text } from 'dripsy';
import AsyncStorage from '@react-native-async-storage/async-storage';
import axios from 'axios';
import { apiEndpoints } from '../apiconfig/apiconfig';
import DateTimePicker from '@react-native-community/datetimepicker';

export default function MyTimelineUserScreen() {
  const [timelineData, setTimelineData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [showPicker, setShowPicker] = useState(false);

  useEffect(() => {
    fetchTimeline(selectedDate);
  }, [selectedDate]);

  const fetchTimeline = async (dateObj) => {
    setLoading(true);
    try {
      const token = await AsyncStorage.getItem('token');
      const formattedDate = dateObj.toISOString().split('T')[0];

      const res = await axios.get(`${apiEndpoints.myTimelineUser}?date=${formattedDate}`, {
        headers: { Authorization: `Bearer ${token}` }
      });

      let data = res.data;

      // Inject auto-clockout if necessary
      const timeline = data?.timeline || [];
      const enhancedTimeline = [...timeline];

      // Get last clockin
      const lastClockInIndex = timeline
        .map((e, i) => (e.status === 'clockin' ? i : -1))
        .filter((i) => i !== -1)
        .pop();

      const hasValidClockOutAfter = (fromIndex) =>
        timeline.slice(fromIndex + 1).some((e) =>
          ['clockout', 'auto-clockout'].includes(e.status)
        );

      if (lastClockInIndex !== undefined && !hasValidClockOutAfter(lastClockInIndex)) {
        const lastClockInTime = timeline[lastClockInIndex].timestamp;
        const fakeClockOutTime = new Date(new Date(lastClockInTime).getTime() + 5 * 60 * 1000); // +5 mins
        enhancedTimeline.push({
          status: 'auto-clockout',
          timestamp: fakeClockOutTime.toISOString()
        });
      }

      setTimelineData({
        ...data,
        timeline: enhancedTimeline
      });
    } catch (err) {
      setTimelineData(null);
      console.error('Error fetching timeline:', err.message);
    } finally {
      setLoading(false);
    }
  };

  const formatTimestamp = (ts) => {
    if (!ts) return '';
    const d = new Date(ts);
    return d.toLocaleString('en-IN', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      hour12: true
    });
  };

  return (
    <ScrollView contentContainerStyle={{ padding: 16 }}>
      <Box sx={{ mb: 16 }}>
        <Text sx={{ fontSize: 24, fontWeight: 'bold', color: '#007AFF', textAlign: 'center', mt: 20 }}>
          ?? Attendance Timeline
        </Text>
      </Box>

      {/* ?? Date Picker */}
      <Box sx={{ alignItems: 'flex-end', mb: 12 }}>
        <Pressable onPress={() => setShowPicker(true)}>
          <Text sx={{ fontSize: 12, color: '#007AFF', fontWeight: 'bold' }}>
            ?? {selectedDate.toDateString()}
          </Text>
        </Pressable>
        {showPicker && (
          <DateTimePicker
            value={selectedDate}
            mode="date"
            display="default"
            maximumDate={new Date()}
            onChange={(event, date) => {
              setShowPicker(false);
              if (date) setSelectedDate(date);
            }}
          />
        )}
      </Box>

      {/* ?? Email Header */}
      {timelineData?.email && (
        <Box sx={{ mb: 12, backgroundColor: '#e6f0ff', padding: 10, borderRadius: 8 }}>
          <Text sx={{ fontWeight: 'bold', fontSize: 16 }}>?? {timelineData.email}</Text>
        </Box>
      )}

      {/* ?? Data Table */}
      {loading ? (
        <ActivityIndicator size="large" color="#007AFF" />
      ) : timelineData?.timeline?.length > 0 ? (
        <Box sx={{ borderWidth: 1, borderColor: '#ccc', borderRadius: 10, overflow: 'hidden' }}>
          {/* Table Header */}
          <Box sx={{ flexDirection: 'row', backgroundColor: '#f0f0f0' }}>
            {['Clock In', 'Updated', 'Clock Out'].map((col, i) => (
              <Box
                key={i}
                sx={{
                  flex: 1,
                  padding: 10,
                  borderRightWidth: i < 2 ? 1 : 0,
                  borderColor: '#ccc'
                }}
              >
                <Text sx={{ textAlign: 'center', fontWeight: 'bold' }}>{col}</Text>
              </Box>
            ))}
          </Box>

          {/* Table Rows */}
          {[...timelineData.timeline]
            // Sort by timestamp descending
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
            // Sort by status priority: clockout(1), update(2), clockin(3)
            .sort((a, b) => {
              const priority = (status) =>
                ['clockout', 'auto-clockout'].includes(status)
                  ? 1
                  : status === 'update'
                  ? 2
                  : status === 'clockin'
                  ? 3
                  : 4;
              return priority(a.status) - priority(b.status);
            })
            .map((item, index) => {
              const isClockIn = item.status === 'clockin';
              const isUpdate = item.status === 'update';
              const isClockOut = ['clockout', 'auto-clockout'].includes(item.status);

              return (
                <Box
                  key={index}
                  sx={{
                    flexDirection: 'row',
                    borderTopWidth: 1,
                    borderColor: '#eee',
                    backgroundColor: index % 2 === 0 ? '#fff' : '#fafafa'
                  }}
                >
                  {/* Clock In Cell */}
                  <Box
                    sx={{
                      flex: 1,
                      padding: 10,
                      borderRightWidth: 1,
                      borderColor: '#ccc',
                      backgroundColor: isClockIn ? '#d9fdd3' : 'transparent'
                    }}
                  >
                    <Text sx={{ textAlign: 'center' }}>
                      {isClockIn ? formatTimestamp(item.timestamp) : ''}
                    </Text>
                  </Box>

                  {/* Update Cell */}
                  <Box
                    sx={{
                      flex: 1,
                      padding: 10,
                      borderRightWidth: 1,
                      borderColor: '#ccc'
                    }}
                  >
                    <Text sx={{ textAlign: 'center' }}>
                      {isUpdate ? formatTimestamp(item.timestamp) : ''}
                    </Text>
                  </Box>

                  {/* Clock Out Cell */}
                  <Box
                    sx={{
                      flex: 1,
                      padding: 10,
                      backgroundColor: isClockOut ? '#ffe0e0' : 'transparent'
                    }}
                  >
                    <Text sx={{ textAlign: 'center' }}>
                      {isClockOut
                        ? `${formatTimestamp(item.timestamp)}${
                            item.status === 'auto-clockout' ? ' ??' : ''
                          }`
                        : ''}
                    </Text>
                  </Box>
                </Box>
              );
            })}
        </Box>
      ) : (
        <Text sx={{ textAlign: 'center', color: 'red', mt: 16 }}>
          ? No data available for selected date.
        </Text>
      )}
    </ScrollView>
  );
}
